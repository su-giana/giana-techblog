---
title: "Introduction"
---
> An operating system is software that manages a computer's hardware. It also provides a basis for application programs and acts as an intermediary between the computer user and the computer hardware.

## What Operating Systems Do
A computer system can be divided roughly into four components : the hardware, the operating system, the application programs and a user. The hardware provides the basic computing resources for the system. The application programs definde the ways in which these resources are used to solve user's computing problems. The operating system controls the hardware and coordiantes its use among the various application programs for the various users.
### User View
The user's view of the computer varies according to the interface being used. The operating system is designed mostly for **ease of use**, with some attention paid to performance and security and none paid to **resource uilization** - how various hardware and sofrware resources are shared. 
### System View
In this context, we can view an operating system as a resource allocator. The operating system acts as the manger of these resources. Facing numerous and possibly conflicting requests for resources, the operating system must decide how to allocate them to specific programs and users so that it can operate the computer system efficiently and fairly. An operating system is a control program. A control program manages the execution of user programs to prevent errors and improper use of the computer.
### Defining Operating System
The fundamental goal of computer system is to execute programs and to make solving user problems easier. The operating system is the one program running at all times on the computer - usually called the **kernel**. Along with the kernel, there are two other types of programs: system programs, which are associated with the operating system but are not necessarily part of the kernel, and application programs, which include all programs not associated with the operation of the system. Mobile operating systems often include not only a core kernel but also **middleware** - a set of software frameworks that provide additional services to application developers. 

<hr>

## Computer-System Organization
A modern general-purpose computer system consists of one or more CPUs and a number of device controllers connected through a common bus that provides access between components and shared memory. The device controller is responsible for moving the data between the peripheral devices that it controls and its local buffer storage. Typically, operating systems have a device driver for each device controller. This device driver understands the device controller and provides the rest of the operating system with a uniform interface to the device. The CPU and the device controllers can execute in parallel, competing for memory cycles. To ensure orderly access to the shared memory, a memory controller synchronizeds access to the memory.
 Typically, operating systems have a **device driver** for each device controller. This device driver understands the device controller and provides the result of the operating system with a uniform interface to the device. The CPU and the device controllers can execute in parallel, competing for memeory cycles. To ensure orderly access to the shared memory, a memory controller synchronizes access to the memory. 

 ### Interrupts
 To start an I/O operation, the device controller loads the appropriate registers in the device controller. The device controller, in turn, examines the contents of these registers to determine what action to take. The controller starts the transfer of data from the device to its local buffer. 
 The device driver then gives control to other parts of the operating system, possibly returning the data or a pointer to the data if the operation was a read.

 #### Overview
Hardware may trigger an interrupt at any time by sending a signal to the CPU, usually by way of the **system bus**. When the CPU is interrupted, it stops what it is doing and immediately transfers execution to a fixed location. The fixed location usually contains the starting address where the service routine for the interrupt is located. The interrupt service routine executes; on completion, the CPU resumes the intterupted computation. 
<img src="../assets/interruptex.jpeg" width="800vw" height="600vw">
A table of potiners to interrupt routines can be used instead ot provide the necessary speed. The interrupt routine is called indirectly through the table, with no intermediate routine needed. Generally, the table of pointers is stored in low memory. This array, or **interrupt vector**, of addresses is then indexed by a unique number, given with the interrupt request, to provide the address of the interrupt service routine for the interrupting device. Operating systems as different as Windows and UNIX dispatch interrupts in this manner. If the interrupt routine needes to modify the processor state, it must explictly save the current state and then restore that state before returning. After the interrupt is services, the saved return address is loaded into the program counter, and the interrupted computation resumes as though the interrupt had not occured.

#### Implementation
The CPU hardware has a wire called the **interrupt-request line** that the CPU senses after executing every instruction. When the CPU detects that a controller has asserted a signal on the interrupt-request line, it reads the interrupt number and jumps to the **interrupt-handler routine** by using that interrupt number as an index into the interrupt vector. The interrupt handler saves any state it will be chaning during its operations, determines the cause of the interrupt,  performs the necessary processing, performs a state restore, and executes _return-from-interrupt_ instruction to return the CPU to the execution state prior to the interrupt. We say that the device controller **raises** an interrupt by asserting a signal on the interrupt request line, the CPU **catches** the interrupt and **dispatches** it to the interrupt handler, and the handler **clears** the interrupt by servicing the device. 
1. We need the ability to defer interrupt handling during critical processing. 
2. We need an efficient way to dispatch to the proper interrupt handler for a device.
3. We need multilevel interrupts, so that the operating system can distinguish between high- and low- priority interrupt and can respond with the appropriate degree of urgency.
__In modern cimputer hardware, these three features are provided by the CPU and the **interrupt-controller hardware**.
<img src="../assets/intrr.png" width="800vw" height="600vw">

Most CPUs have two interrupt request lines. One is the **nonmaskable interrupt**, which is reserved for event such as unrecoverable memory errors. The second interrupt line is **maskable**: it can be turned off by the CPU before the execution of critical instruction sequences that must not be interrupted. The maskable interrupt is used by device controllers to requst services. 
Interrupt chaining is each element in the interrupt vector points to the head of a list of interrupt handlers. When an inerrupt is raised, the handlers on the corresponding list are called one by one, until one is found that can service the request. This structure is a compromise between the overhead of a huge interrupt table and the inefficiency of dispatching to a single interrupt handler. 
The events from 0 to 31, which are nonmaskable, are used to signal various error conditions. The events from 32 to 255, which are maskable, are used for purposes such as device-generated interrupts. The interrupt mechanism also implements a system of **interrupt priority levels**. These levels enable the CPU to defer the handling of low-priority interrupts without masking all interrupts and makes it possible for a high-priority interrupts to preempt the execution of a low-priority interrupt.