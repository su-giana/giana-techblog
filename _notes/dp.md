---
title: "Dynamic Programming"
---
from [[algorithm]]

## Overlapping subproblems
In wide scope, dymanic programming means approach to problem solving such as divide and conquer. Algorithm using dynamic programming divides problem into subproblems and merge its result to overall solution. the difference between them is the way the algorithm split the problems. In dynamic programming, some subproblems could be reused to solve other more than two problems. So, we need to memorize the results of subproblems in some memory location, which called cache. Overlapping subproblems are subproblem overlapped more than twice. Recursion generates bunch of overlapped computation and it exponentially inceases as depth of division increases. 
Memorization : optimization technique that store result of subproblems and reuse them to solve bigger problem
### binomial coefficient with memorization
```C++
int cahce[30][30];
int bino2(int n, in r)
{
    if(r == 0 || r == n)    return 1;
    if(cache[n][r] != -1)   return cache[n][r];
    return cache[n][r]   = bino2(n-1, r-1) + bino2(n-1, r);
}
```

## Referential transparent function
> function which returns same result when input is fixed
Memorization can be applied to referential transparent function only

## Memorization Implementation Pattern
- Consider base case first
- Initialize cache with the value can be generated by the function
ex) if minimum return of the function is 0, initialize cache with -1
- use reference type -> we do not need to use additional time or space to change the array's content individually
```C++
// example of memorization
int cache[2500][2500];
int someObsecureFunction(int a, int b)
{
    // consider base case first
    if(...) return ...;
    // return result of (a,b) directly if it is memorized
    int& ret = cache[a][b];
    if(ret != -1)   return ret;
    // compute in here
    ...
    return ret;
}
int main()
{
    // initialize char array with memset()
    memset(cache, -1, sizeof(cache));
}
```
### Jump Game
```C++
// Jump Game : https://algospot.com/judge/problem/read/JUMPGAME
int n, board[100][100];
int cache[100][100];
int jump2(int x, int y)
{
    if(y>=n || x>=n)    return 0;
    if(y==n-1 && x>=n-1)    return 1;
    int& ret = cache[x][y];
    if(ret != -1)   return ret;
    int jumpSize = board[x][y];
    return ret = (jump2(x, x+jumpSize) || jump2(y, y+jumpSize));
}
```

### Wild Card
```C++
//algospot.com/judge/problem/read/WILDCARD
// Exhaustive search for wildcard problem
bool match(const string& w, const string& s)
{
    int pos = 0;
    while(pos < s.size() && pos < w.size() && (w[pos] == '?' || w[pos] == s[pos))
        pos++;
    
    if(pos == w.size())
        return pos == s.size();
    
    if(w[pos]  == '*')
    {
        for(int skip = 0 ; pos + skip <= s.size() ; skip++)
        {
            if(match(w.substr(pos+1), s.substr(pos+skip)))
                return true;
        }
    }
    return false;
}

```C++
// Dynamic Programming for wildcard problem
int cache[101][101];
string W, S;
bool matchMemorized(int w, int s)
{
    int& ret = cache[w][s];
    if(ret!=-1) return ret;
    while(s<S.size() && W.size() && (W[w] == '?' || W[w] == S[s]))
    {
        w++;
        s++;
    }
    if(w == W.size())   return ret = (s == S.size());

    if(W[w] == '*')
    {
        for(int skip = 0 ; skip+s < s.size() ; skip++)
        {
            if(matchMemorized(w+1, s+skip))
                return ret = 1;
        }
    }
    return ret = 0;
}
```

```C++
// DP with better solution
int cache[100][100];
string W, S;
bool matchMemorized(int w, int s)
{
    int& ret = cache[w][s];
    if(ret!=1)  return ret;

    if(w<W.size() && s<S.size() && (W[w] == '?' || S[s] == W[w]))
        return ret = matchMemorized(w+1, s+1);

    if(W[w] == '*')    
    {
        if(matchMemorized(w+1, s) || (s<S.size() && matchMemorized(w, s+1)))
            return ret = 1;
    }
}
```

### TRIANGLE maximum path
```C++
//https://algospot.com/judge/problem/read/TRIANGLEPATH
int n, triangle[100][100];
int cache2[100][100];
int path2(int x, int y)
{
    //base case
    if(y == n-1)    return triangle[x][y];
    // memorization
    int& ret = cache2[x][y];
    if(ret != -1)   return ret;
    return ret = max(path2(x, y+1), path2(x+1, y+1)) + triangle[x][y];
}
```

## Theory : optimal substructure
> condition which is established in some problems and the way of division
In above case, one problem divides to two problems and if we solve each subproblem in optimal status,  we can reach to optimal result of overall problem.

