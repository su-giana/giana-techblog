---
title: "Dynamic Programming"
---
from [[algorithm]]

## Overlapping subproblems
In wide scope, dymanic programming means approach to problem solving such as divide and conquer. Algorithm using dynamic programming divides problem into subproblems and merge its result to overall solution. the difference between them is the way the algorithm split the problems. In dynamic programming, some subproblems could be reused to solve other more than two problems. So, we need to memorize the results of subproblems in some memory location, which called cache. Overlapping subproblems are subproblem overlapped more than twice. Recursion generates bunch of overlapped computation and it exponentially inceases as depth of division increases. 
Memorization : optimization technique that store result of subproblems and reuse them to solve bigger problem
### binomial coefficient with memorization
```C++
int cahce[30][30];
int bino2(int n, in r)
{
    if(r == 0 || r == n)    return 1;
    if(cache[n][r] != -1)   return cache[n][r];
    return cache[n][r]   = bino2(n-1, r-1) + bino2(n-1, r);
}
```

## Referential transparent function
> function which returns same result when input is fixed
Memorization can be applied to referential transparent function only

## Memorization Implementation Pattern
- Consider base case first
- Initialize cache with the value can be generated by the function
ex) if minimum return of the function is 0, initialize cache with -1
- use reference type -> we do not need to use additional time or space to change the array's content individually
```C++
// example of memorization
int cache[2500][2500];
int someObsecureFunction(int a, int b)
{
    // consider base case first
    if(...) return ...;
    // return result of (a,b) directly if it is memorized
    int& ret = cache[a][b];
    if(ret != -1)   return ret;
    // compute in here
    ...
    return ret;
}
int main()
{
    // initialize char array with memset()
    memset(cache, -1, sizeof(cache));
}
```
### Jump Game
```C++
// Jump Game : https://algospot.com/judge/problem/read/JUMPGAME
int n, board[100][100];
int cache[100][100];
int jump2(int x, int y)
{
    if(y>=n || x>=n)    return 0;
    if(y==n-1 && x>=n-1)    return 1;
    int& ret = cache[x][y];
    if(ret != -1)   return ret;
    int jumpSize = board[x][y];
    return ret = (jump2(x, x+jumpSize) || jump2(y, y+jumpSize));
}
```

### Wild Card
```C++
//algospot.com/judge/problem/read/WILDCARD
// Exhaustive search for wildcard problem
bool match(const string& w, const string& s)
{
    int pos = 0;
    while(pos < s.size() && pos < w.size() && (w[pos] == '?' || w[pos] == s[pos))
        pos++;
    
    if(pos == w.size())
        return pos == s.size();
    
    if(w[pos]  == '*')
    {
        for(int skip = 0 ; pos + skip <= s.size() ; skip++)
        {
            if(match(w.substr(pos+1), s.substr(pos+skip)))
                return true;
        }
    }
    return false;
}

```C++
// Dynamic Programming for wildcard problem
int cache[101][101];
string W, S;
bool matchMemorized(int w, int s)
{
    int& ret = cache[w][s];
    if(ret!=-1) return ret;
    while(s<S.size() && W.size() && (W[w] == '?' || W[w] == S[s]))
    {
        w++;
        s++;
    }
    if(w == W.size())   return ret = (s == S.size());

    if(W[w] == '*')
    {
        for(int skip = 0 ; skip+s < s.size() ; skip++)
        {
            if(matchMemorized(w+1, s+skip))
                return ret = 1;
        }
    }
    return ret = 0;
}
```

```C++
// DP with better solution
int cache[100][100];
string W, S;
bool matchMemorized(int w, int s)
{
    int& ret = cache[w][s];
    if(ret!=1)  return ret;

    if(w<W.size() && s<S.size() && (W[w] == '?' || S[s] == W[w]))
        return ret = matchMemorized(w+1, s+1);

    if(W[w] == '*')    
    {
        if(matchMemorized(w+1, s) || (s<S.size() && matchMemorized(w, s+1)))
            return ret = 1;
    }
}
```

### TRIANGLE maximum path
```C++
//https://algospot.com/judge/problem/read/TRIANGLEPATH
int n, triangle[100][100];
int cache2[100][100];
int path2(int x, int y)
{
    //base case
    if(y == n-1)    return triangle[x][y];
    // memorization
    int& ret = cache2[x][y];
    if(ret != -1)   return ret;
    return ret = max(path2(x, y+1), path2(x+1, y+1)) + triangle[x][y];
}
```

## Theory : optimal substructure
> condition which is established in some problems and the way of division
In above case, one problem divides to two problems and if we solve each subproblem in optimal status,  we can reach to optimal result of overall problem.

### LIS(Longest Increasing Subsequence) problem
```C++
// Exhausive search
int lis(const vector<int>& A)
{
    if(A.empty())   return 0;
    int ret = 0;
    for(int i = 0 ; i<A.size() ; i++)
    {
        vector<int> B;
        for(int j = 0 ; j<A.size() ; j++)
        {
            if(A[i] < A[j])
                B.push_back(A[j]);
        }
        ret = max(ret, 1+lis(B));
    }
    return ret;
}
```
```C++
//dp
int n;
int cache[101], S[100];
int lis(int start)
{
    int& ret = cache[start+1];
    if(ret != -1)   return ret;
    ret = 1;
    for(int next = start+1 ; next<n ; ++next)
    {
        if(start == -1 || S[start] < S[next])
            ret = max(ret, lis(next) + 1);
    }
    return ret;
}
```

## Optimization of dynamic programming
1. Construct exclusive search algorithm which generate every possible answer candidate and return optimized result
2. Distort definition of subproblem to return the answer in defined range.
3. Reduce information related to previous selection if it is not needed. 
4. If we convert input to string or array, apply memorization.

### JLIS(Joined Longest Increaseing Subsequence)
```C++
const long long NEGINF = numeric_limits<long long>::min();
int n, m, A[100], B[100];
int cache[101][101];

int jlis(int indexA, int indexB)
{
    int& ret = cache[indexA+1][indexB+1];
    if(ret != -1)   return ret;

    ret=2;
    long long a = (indexA == -1 ? NEGINF : A[indexA]);
    long long b = (indexB == -1 ? NEGINF : B[indexB]);
    long long maxElement = max(a, b);

    for(int nextA = indexA + 1 ; nextA<n ; nextA++)
    {
        if(maxElement < A[nextA])
            ret = max(ret, jlis(nextA, indexB) + 1);
    }
    for(int nextB = indexB + 1 ; nextB<n ; nextB++)
    {
        if(maxElement < B[nextB])
            ret = max(ret, jlis(indexA, nextB) + 1);
    }
    return ret;
}
```
### PI
```C++
// https://algospot.com/judge/problem/read/PI
const int INF = 987654321;
string N;
int classify(int a, int b)
{
    string M = N.substr(a, b-a+1);
    // if all char is same -> dif. == 1
    if(M == string(M.size(), M[0]))     return 1;
    // check if it is arithmetric progression
    bool progressive = true;
    for(int i = 0 ;i<M.size() - 1 ; ++i)
    {
        if(M[i+1] - M[i] != M[1] - M[0])
            progressive = false;
    }
    if(progressive && abs(M[1] - M[0]) == 1)
        return 2;
    bool alternating = true;
    for(int i = 0 ; i<M.size() ; i++)
    {
        if(M[i] != M[i%2])
            alternating = false;
    }
    if(alternating) return 4;
    if(progressive) return 5;
    return 10;
}
int cache[10002];
int memorize(int begin)
{
    if(begin == N.size())   return 0;
    int& ret = cache[begin];
    if(ret != -1)   return ret;
    ret = INF;
    for(int L = 3 ; L<=5 ; ++L)
    {
        if(begin + L <= N.size())
        {
            ret = min(ret, memorize(begin + L) + classify(begin, begin + L - 1));
        }
    }
    return ret;
}
```

### Quantization
```C++
const int INF = 987654321;
int n;
int A[101], pSum[101], pSqSum[101];
void precalc()
{
    sort(A, A+n);
    pSum[0] = A[0];
    pSqSum[0] = A[0] * A[0];
    for(int i = 1 ; i<n ; i++)
    {
        pSum[i] = pSum[i-1] + A[i];
        pSqSum[i] = pSqSum[i-1] + A[i] * A[i];
    }
}
int minError(int lo, int hi)
{
    int sum = pSum[hi] - (lo == 0 ? 0 : pSum[lo-1]);
    int sqSum = pSqSum[hi] - (lo == 0 ? 0 : pqSum[lo-1]);
    int m = int(0.5 + (double)sum / (hi-lo+1));
    int ret = sqSum - 2 * m * sum + m * m * (hi-lo+1);
    return ret;
}
int cache[101][11];
int quantize(int from, int parts)
{
    // base case : if we quantize every numbers
    if(from == n)   return 0;
    // base case : though we can bind more, return very big value
    if(parts == 0)  return INF;
    int& ret = cache[from][parts];
    if(ret != -1)   return ret;
    ret = INF;
    // find smallest value varying length of parts
    for(int partSize = 1 ; from+partSize <= n ; partSize++)
    {
        ret = min(ret, minError(from, from + partSize - 1) + quantize(from + partSize , parts - 1));
    }
    return ret;
}
```

### Tiling
```C++
// https://www.algospot.com/judge/problem/read/TILING2
const int MOD = 10000000007;
int cache[101];
int tiling(int width)
{
    // base case : width<=1
    if(width <= 1)  return 1;
    //memorization
    int& ret = cache[width];
    if(ret != -1)   return ret;
    return ret = (tiling(width-1) + tiling(width-1)) % MOD;
}
```

### Count the number of valid path on triangle
```C++
int countCache[100][100];
int count(int x, int y)
{
    if(y == n-1)    return ret;
    // Memorization
    int& ret - countCache[x][y];
    if(ret != -1)   return ret;
    ret = 0;
    if(path(x+1, y+1) >= path(x, y+1))  ret += count(x+1, y+1);
    if(path(x+1, y+1) <= path(x, y+1)   ret += count(x, y+1);
    return ret;
}
```
