---
title: Slash23 코어뱅킹 MSA 전환기 후기
---
# 토스는 왜 코어뱅킹을 MSA로 전환했을까?

---

제가 2023년에 가장 큰 영향을 준 영상을 뽑아야 한다면, 토스 컨퍼런스인 Slash23의 [은행 최초 코어뱅킹 MSA 전환기 (feat. 지금 이자 받기)](https://www.youtube.com/watch?v=amTJyIE1wO0&t=5s) 영상을 뽑습니다. 2021년 소프트웨어공학과로 전과한 이후, 대부분의 학생처럼 도메인도 없고 좋아하는 분야도 없었지만 이 영상을 보고 처음 특정 도메인에 흥미를 가지게 되었어요. 
 이 영상이 저에게 충격적으로 다가왔던 이유는 "특정 도메인의 기술"이란 이유로 **다른 기술을 적용하지 못하는 경우**가 있다는 개념이 없어서 였습니다. 그 계기로 처음 금융이라는 분야를 다시 생각해보게 되었어요. 직접적인 코어 뱅킹에 관한 자료는 많이 찾을 수 없었지만, PG라든지 많은 핀테크 기술들을 접하게 되면서 자연스럽게 그 분야에 빠져들었어요. 그 영향으로 2023년 제 첫 취업 목표는 은행이나 PG 등 **돈에 관련된 트래픽**을 다루는 분야에 갈 만큼 좋은 실력을 기르는게 되었습니다. 혁신적인 페이, 금융 서비스들을 만드는 회사에서 같은 ***책임***을 져보고 싶다는 의지를 가지고 다시 공부해 나가 보자구요!
 서론이 길어졌지만, 본격적으로 의문을 던지고 제 의견을 말해보기 전에 영상을 쭉 따라가 보겠습니다. 모든 이미지는 토스 컨퍼런스 slash23에서 가져왔습니다. 저같이 딥한 기술 용어에 생소한 대학생들을 위해 군데군데 설명을 달아 놓았습니다. 더 깊은 설명은 첨부된 링크를 따라가 주세요!

## 현재 은행 시스템의 소개

---

![](https://i.imgur.com/8aFO6Fz.png)
저도 내부를 모두 알지는 못해서 서투를 수 있다는 점을 양해 부탁드립니다. 일단 저희가 은행에 접근할 때는 다른 서비스처럼 DB에 바로 요청을 꽂아넣지 않습니다. 저희의 트래픽은 일단 **채널계**에 도달해요. 그리고 그 채널계가 **코어뱅킹, 즉 계정계**에 트래픽을 전달하는 구조입니다. 이 구조를 선택한 데에는 역사적인 이유가 있지만, 기술과는 조금 떨어져있기 때문에 과감하게 생략했습니다.
![](https://i.imgur.com/xf6wiCm.png)
채널계에 트래픽을 날리면 그게 코어뱅킹으로 전달된다는 사실도 중요하지만, 개발자(아마도?)인 우리가 집중해야할 부분은 각 계의 아키텍처입니다. 토스뱅킹의 채널계는 MSA로 구성되어 있고 코어뱅킹 서버는 큰 **모놀리식 아키텍처**로 되어있습니다. 모놀리식을 사용함으로써 트랜잭션 처리에는 용이했지만, 확장 용이성과 장애 대응성에는 많이 떨어지는 모습을 보였습니다. 대량의 트래픽을 처리하기 위해서 토스는 이를 MSA로 변화시키고자 했어요. 

## 지금 이자 받기 서비스

---

특히, 토스의 지금 이자 받기 서비스는 서버에 영향을 줄만큼 큰 트래픽을 발생시키는 이벤트였습니다. 지금 이자 받기 서비스는 대출에 관련되지 않은 서비스이기 때문에 **수신**에 해당합니다. 반대로 대출과 연관된 서비스는 여신이에요. 저도 이 영상에서 처음 봤었습니다 ㅎㅎ.

![](https://i.imgur.com/j0IBXNS.png)

해당 이벤트의 큰 트래픽에 대응하기 위해서 토스는 수신의 이자 받기 서비스를 MSA로 변경하려는 시도를 했습니다. 역시 큰 회사이고 실제 서비스이다보니 비즈니스 로직 자체가 꽤나 복잡하더라구요. 

![](https://i.imgur.com/NO1MH3D.png)

비즈니스 프로세스는 이렇습니다.
1. 자금 이자 받기를 요청한 고객 정보를 조회한다
2. 이자를 받을 상품의 약관을 조회한다
3. 실제 이자 계산은 아래와 같습니다   $$계좌 잔액 * 상품 금리 * (이자받기를 요청한 전 날 - 마지막으로 이자를 받은 날) / 365 = 이자 금액$$
4. 계산된 이자에서 국내 소득세법상 이자소득세 14%와 지방 소득세 1.4%를 제한다
5. 마지막 계산된 금액을 송금한다

# 서버의 구현

---

요런 기술 스택을 사용했다네요! 해당 서비스는 수신 서버만 필요한 것이 아니라 고객의 정보들이 필요했기 때문에, 이 모든 것을 하나의 마이크로 서버에서 처리하는 것은 MSA의 장점을 못 살리는 것이라 생각하여서 DDD를 택하셨다고 해요.
![](https://i.imgur.com/XRpznEL.png)
## Domain-Driven Development
도메인 주도 개발은 무엇일까요? 일단 도메인부터 살펴봅시다! 도메인은 **소프트웨어로 해결하고자 하는 문제 영역**을 의미합니다. 이렇게 말하면 조금 어렵죠? 예를 들어, 지금처럼 이자 받기 서비스를 생각해볼게요. 이자 받기 서비스에서는 당연히 이자를 받는 것이 주된 문제점, 구현점이겠죠? 여기서 이자 받기 서비스 자체가 도메인이라고 할 수 있습니다. 
도메인은 **서브 도메인**을 가지게 됩니다. 만약 이자 받기 서비스라는 도메인이 있다면 아래에는 이자 계산하기, 세금 계산하기, 이자 송금하기는 자연스럽게 서브 도메인이 되겠네요. 여기서 중요한 것은 **비즈니스 로직은 도메인 모델에만 위치해야 한다는 것**입니다. 이 if(kakao)영상 [링크](https://www.youtube.com/watch?v=4QHvTeeTsj0)를 보면 조금 이해가 되실거예요.

![](https://i.imgur.com/ATIFZtP.png)

한 번의 비즈니스 로직이 위와 같이 복잡하게 구성되어있었던 거죠. 트랜잭션으로 묶지 않아도 되는 도메인은 별도의 마이크로 서버로 구성하셨고, **API의 호출**을 통하여 비즈니스 의존성을 느슨하게 가져가도록 하셨습니다.

## 이자 지급 서비스의 동시성 제어
---

대규모 트래픽 처리의 꽃은 동시성 제어와 처리 지연의 최소화라고 생각합니다. MSA로 API 콜을 이용하다보니 당연히 동시성 제어가 어려워질 수밖에 없는데요, 잔액을 갱신하는 채널이 타행 입금, 자행 입금 등 너무나 많기 때문에 일반적으로 사용되는 **Redis Global Lock**만으로는 동시성 제어를 할 수 없었습니다.
지금이자받기 로직의 잔액 갱신하기 API가 메인 비즈니스 로직이기 때문에 계좌 단위 현재 잔액 데이터에 대해서만 고유하게 **Row Locking**이 걸리게 해 동시성을 보장했어요. 
### 동시성 제어의 정도
저같은 감자들은 잘 이해하지 못하는 말이지만, `synchronized`같은 단어들로 모든 동시성 제어가 되는 건 아닙니다. 

> [!INFO] 가장 기본은 synchronized 키워드!
> 자바에서는 `synchronized` 키워드를 제공하고 **모니터 기반으로 상호 배제** 기능을 제공합니다.
- 하지만 이 경우에는 **같은 프로세스**에서만 상호 배제를 보장합니다
- 즉, 만약에 지금같이 분산화 된 환경에서는 사용할 수 없겠죠?

> [!INFO|red] 분산 환경에서 상호 배제를 구현하기 위해서는 Redis Global Lock!
> 분산락을 구현하기 위해서는 **같은 임계 영역**을 공유하며 서로 같은 공간을 공유해야 합니다. 만약에 우리가 버스를 예매한다고 생각해 보아요. 각자의 집에서 "같은 버스 터미널과 같은 버스"를 보고 있어야 자원에 대한 논의가 일어날 수 있습니다.
- 이 분산락을 구현하기 위해서 응용하는 것 중에 **하나**가 Redis예요. MySQL의 네임드 락, Redis, Zookeeper 등이 있습니다.
- Reids의 SETNX 문법이나 Message Broker를 활용할 수 있어요. 
- 자세한 내용은 [이 링크](https://hudi.blog/distributed-lock-with-redis/)에 잘 나와있습니다.

#### 어떻게 Row Locking을 구현하셨을까? 🧐 

---

##### 송금의 ACID 원칙

---
송금의 Transaction은 크게 두 가지 행위가 하나로 묶인 작업이다. 첫 번재로, 보내는 사람의 계좌에서 돈을 빼야 하고, 두 번째로 받는 사람의 계좌에 돈을 추가해야 한다. 해당 작업에서 ACID는 각각
- Atomicity : 부분적 성공을 금한다. 송금하는 사람의 계좌에서 돈은 빠져나갔는데, 입금이 안되는 상태를 방지한다
- Consistency : transaction이 끝날 때 DB의 여러 제약 조건에 맞는 상태를  보장한다. 송금하는 사람의 계좌 잔고가 0보다 작아지면 안되는 것 등등
- Isolation : transaction이 진행되는 중간 상태의 데이터를 다른 transaction이 볼 수 없도록 보장한다. 예를 들어, 출금은 이루어졌지만 아직 입금되지 않은 상태를 다른 transaction이 읽으면 안된다
- Durability : transaction이 성공했을 경우 해당 결과가 영구적으로 적용된다. 한 번 송금이 성공하면 은행 시스템에 장애가 발생하더라도 송금이 성공한 상태로 복구한다.

##### InnoDB의 Row-Level Lock

---

**Row Locking**은 테이블의 **row**마다 걸리는 Lock에 해당한다. 크게 **Shared Lock**과 **Exclusive Lock** 두 가지로 나뉜다.
- Shared Lock은 **read에 대한 lock**이다. `SELECT ... FROM SHARE` 등 일부 `SELECT` 쿼리를 이용할 때 사용된다.
- Exclusive Lock은 **write**에 대한 **lock**이다. `SELECT ... FOR UPDATE`나 `UPDATE`, `DELETE` 등의 수정 쿼리를 날릴 때 각 row에 적용된다.
> [!NOTE] S Lock, X Lock 규칙
> - 여러 transaction이 동시에 한 row에 S Lock을 걸어, 읽어 들일 수 있다.
> - S Lock에 걸려있는 row에 다른 transaction이 X Lock을 걸 수 없다.
> - X Lock이 걸려있는 row에는 다른 공유, 베타락 접근이 불가능하다.

결론을 내보자면, `FOR UPDATE`문이나 `FOR SHARE`문 등을 사용하셨다고 추측할 수 있습니다.

## 성능 개선을 위한 비동기 처리

---

위의 이자 지급 프로세스를 위해서 20개의 테이블에 80번의 수정 작업을 거치시다보니, 응답 시간이 300ms으로 굉장히 느려졌는데요. 이를 개선하기 위해 기존 지금 이자 받기 트랜잭션에서 **분리 가능한 테이블**을 **Kafka**를 이용해 트랜잭션에서 분리하셨습니다. 

---
### Kafka가 뭐죠?
레드햇의 공식 문서를 참고해볼까요?
![|500](https://i.imgur.com/NC9cPaq.png)
흠, 그렇군요. 카프카를 이해하기 위해서는 메세지 큐와 메세지/이벤트 브로커에 대한 선행 이해가 필요합니다.
#### 메세지큐
메세지큐는 프로세스간의 데이터를 교환할 때 사용되는 기술인데요, 아래와 같은 구조로 이루어져있습니다. Producer에서 제공한 정보를 Consumer로 전달하고, 그 과정에 Producer의 정보를 저장하며 Consumer에 제공하는 곳에 우리가 사용하는 Message Queue 즉, 브로커입니다.
![](https://i.imgur.com/EErBKmH.png)
#### 메세지 브로커/이벤트 브로커
이벤트 브로커는 메세지 브로커의 역할인 "publisher의 메세지를 큐에 저장하고 consumer가 가져갈 수 있도록 해주기"를 수행할 수 있습니다. 둘의 차이점은 메세지 브로커의 경우 데이터를 가져갈 시에 큐에서 데이터를 삭제하며 이벤트 브로커는 이를 저장하여 특정 시점에 consumer가 다시 consume하게 할 수 있다는 점이다. 또한, 대용량 처리에 있어서는 메세지 브로커보다 많은 양을 처리할 수 있습니다.

이와 비슷한 다수의 서비스들이 있지만, 그에 대한 정보는 [메세지큐 비교하기 (미공개) 링크]()에서 확인 바랍니다. 같은 맥락으로 토스가 많은 기술 중 카프카를 선택한 이유는 아래에 후술하겠습니다.

---

트랜잭션 분리의 기준은 DB의 **쓰기 지연**이 발생할 때, 고객의 통장 데이터가 실시간으로 문제가 발생하느냐?로 설정하였습니다. 따라서, 지금 이자 받기 트랜잭션과 묶이지 않아도 되는 세금 처리 같은 로직, 데이터 모델의 DML은 트랜잭션을 분리하셨습니다. 
![](https://i.imgur.com/OVNjxPN.png)
자세히 살펴보면, 이자 계산이 끝난 후 Kafka 서버에 "세금" **토픽**으로 produce한 후 비동기 처리 서버가 Consume하여 세금 DB에 저장하도록 구현하신거죠. 해당 행동은 준 실시간으로 일어나기 때문에 이자 받기 거래는 정장적으로 끝납니다. 
그럼에도 불구하고, 정상 처리되지 않을 때를 대비하여 **Dead Letter Queue**를 이용하여 세금 DB의 트랜잭션을 안정하게 보장하고, 재처리시 중복 세금 업데이트를 방지하도록 API의 멱등성을 확보하셨습니다.
해당 작업을 통해서 토스 코어뱅킹 팀은 80회 DML을 50회의 자금 이자 받기 트랜잭션 DML과 30회의 세금 DML로 분리하여 동시 처리해 총 50DML로 개선할 수 있었습니다. 

## Redis를 활용한 캐싱 전략
---

기존에는 "지금 이자 받기"를 이용할 때마다 이자를 계산하여 반환하였습니다. 고객은 하루에 한 번만 이자를 받을 수 있으므로 이를 Redis를 이용하여 하루에 한 번만 연산이 일어나게 하도록 구현하여 계산한 값은 Redis에 저장하여 캐싱하게 구성하셨습니다. 물론, 데이터 만료 일자를 00시로 설정하여 잘못된 계산을 방지했습니다. 
![|500](https://i.imgur.com/mbapzPT.png)

# 서비스 마이그레이션과 성과

---

## 서버 마이그레이션
---

이자 지급 마이크로 서버와 코어 뱅킹 서버의 정합성 비교를 위해 둘이 불일치 하면, 모니터링 채널에 알림을 보내 원인을 수정하는 과정을 수행하셨습니다. 또한, 실제와 비슷한 테스팅 서버인 스테이징 서버에서도 같은 과정을 반복했습니다.
![](https://i.imgur.com/1umZzkE.png)

정확성을 위해 다양한 고객, 계좌 상태에 대한 테스트 케이스를 수립하여 통합 테스트를 진행하셨습니다. 
![](https://i.imgur.com/Fdkxh9b.png)

기존 은행은 빅뱅 배포 방식을 탈피하고 순차 배포 방식을 선택하여 시스템 중단 없이 안정적인 전환을 할 수 있었습니다. 

## 성과

---

> [!NOTE] 코어 뱅킹과 별도의 서버 구축
> - MCI와 통하지 않고 자체적으로 요청을 받고 응답을 주기 때문에 코어뱅킹 서버와 서로 영향을 주지 않는 독립적인 서비스를 구축
> - 코어 뱅킹 서버의 부하가 이자 지급 마이크로 서버에 주는 영향도를 제한

> [!NOTE] 다양한 팀들과의 유기적 협업이 가능해짐
>  - 다양한 모듈을 개발하여 다른 팀들이 마이크로 서버를 호출할 수 있는 구조를 만들어 더 확장성 있는 서버를 만들게 됨
>  - 새로운 코어뱅킹 거래를 이식하는 데에 있어 확장성이 좋아짐

> [!NOTE] 레거시 코드 청산

> [!NOTE] 성능 개선
> 
![](https://i.imgur.com/YQ8B7ON.png)

---

# 들었던 의문들과 나름의 해답

---

## 1. 약관 같은 복잡한 친구들은 어떻게 비즈니스 로직을 짜야하지?

---

토스 내에서는 당연히 약관을 관리하는 방법이 따로 있겠지만, 아직 실무를 경험하지 않은 입장에서 약관을 그대로 구현하는 것이 상상이 되지 않았습니다. 약관의 조건의 조건의 조건을 위한 DB와 테이블을 따로 두려나? 아니면 글로 남기려나? 그러면 코딩이 안될텐데? 그래서 직접 상품 예시를 들고 코드를 짜보려 합니다.
일단 토스 코어뱅킹같은 경우에는 NEXT Challenge Core Banking 직군 기준 스택을 보았을 때 **MDD**를 사용하고 있는데요. 토스뱅크 자유 적금을 큰 예시로 들어볼게요. 일단 있어야 하는 정보들을 표로 표시해봅시다.

|이름|내용|형식|비고|
|---|---|---|---|
|가입대상|토스뱅크 통장 또는 토스뱅크 서브 통장을 보유한 실명의 개인|Integer|인덱싱|
|예금 종류|정기 적금, 자유 저금|Integer|인덱싱|
|최초 가입금액|0원~300만원|Long|최소, 최대 구분 필요|
|월 저금 금액|최대 300만원|Long|최소, 최대 구분 필요|
|입금 방법|연결된 토스 통장|Integer|인덱싱
|만료 기간||LocalDate||
|자동이체 여부|자동이체 정보|자동이체 객체||
|가입 일자||LocalDate||
|금리정보|금리정보들|금리정보 객체||
|연결 계좌|계좌번호|String||
|상품 유효 여부|상품이 유효한지를 나타냄|Boolean||

가입 대상과 예금 종류는 Integer로 인덱싱 한 후 비즈니스 로직에서 처리한다고 생각해도, 자동이체 정보와 금리 정도를 담을 두 개의 테이블이 적어도 필요하네요! 어떤 인덱스가 어떤 타입의 유형을 나타내고 있는지 철저한 문서화가 필요하겠네요. 마저 자동이체 객체와 금리정보 객체를 구현해봅시다.

|이름|내용|형식|비고|
|---|---|---|---|
|자동이체 주기|기간(일)|Integer||
|자동이체 금액|가입 시 지정한 금액|Long||
|자동이체 시작|가입일이 속한 달의 다음달|LocalDate||
|자동이체 종료|만기일이 속한 달의 전달|LocalDate||
|자동이체 유효 여부|자동이체를 수행중인가?|Boolean||
|자동이체 상한|최대 자동이체 금액|Long||
|자동이체 하한|최소 자동이체 금액|Long||

|이름|내용|형식|비고|
|---|---|---|---|
|기본 금리|계약기간별 금리|금리 객체|금리-기본금리 객체 관계 테이블 필요|
|우대금리|우대금리|Double||
|우대금리 제공조건|우대금리 제공조건|Integer|글을 모두 코드로 표현할 수 없으므로 인덱싱 필요|
|이자지급방법|이자지급방법|Integer|글을 모두 코드로 표현할 수 없으므로 인덱싱 필요|
|중도해지금리|고시한 중도해지금리로 계산하여 지급|Integer|금리객체|금리-중도해지금리 관계 테이블 필요|
|만기 후 금리|만기일부터 해지일 전일까지의 기간을 만기일 당시 고시한 이 상품의 만기 후 금리로 계산해 지급|금리|금리-만기후금리 테이블 필요|

쉽지 않네요.. 금리를 **계산**하는 것은 비즈니스 로직인데, 그러면 이 수식에 관련된 상수들을 저장하는 것을 DB에서 하는 것이 맞는 지에 대한 의심이 계속 들고 있습니다. 그렇다고 금리 정보를 코드에 하드코딩하는 것은 보안적 미친 짓이라 생각이 드네요.. 애초에 하나의 상품을 팩토리 패턴을 이용해서 단일화 하는게 불가능한 시도인 듯 하기도 하고요.. 흠! 글이 길어지는 듯하니, 우아한 테크코스 미션처럼 작은 어플리케이션을 짜서 아래에 첨부해 두겠습니다. 
## 2. 서버를 물리적으로 스케일하는 것이 정말 비효율적인가?
이게 사실 제일 궁금한 점인데요, 저의 관점에서 트래픽이 늘어나면 그에 따라 서버를 스케일 업 해서 작동시키는 것이 MSA로 전환하는 것보다 비용이 크다고 판단하셨을까요? 그 정도로 토스의 트래픽이 컸던 것이라고 당장은 추측할 수밖에 없지만, 저는 같은 서버를 두 대 두고 로드밸런싱해서 쓰는 것도 나쁘지 않다고 생각 했습니다.
이 부분은 제가 토스 내부 사정을 모르기 때문에 잘 확신이 들지 않지만, 토스가 아무래도 좋은 개발자 분들이 많다보니 공학적으로 이 문제를 타파하고 싶으던 걸까?라는 생각이 들기는 합니다. 그리고 토스 유저가 정말 글로벌하게 늘어나면 분명 서버 스케일 업으로는 해결되지 않는 문제들이 있긴 하죠. 토스가 기술적, 경영적으로 지향하는 방법을 찾아보는게 이 답을 풀 수 있는 이유가 될 수 있다는 생각이 드네요. 
사실 토스 기술 컨퍼런스만 정말 주구장창 봤지 경영과 팀 문화에 대해서는 조사가 소홀하다는 생각이 제 머리를 스쳤습니다. 곧 토스에서 발행된 매체들을 보고 생각을 정리해서 포스팅을 올려볼게요!

## 3. 왜 레디스 글로벌 락은 부족한가?

## 4. 왜 분산락을 구현하기 위해서 Redis를 사용할까? MySQL 네임드락도, Zookeeper도 아니고

## 5. 성능을 개선하기 위해 다 제쳐두고 카프카를 쓰신 이유는? 다른 비슷한 툴은 없었나?
